/*
 * Pathfinder.cpp
 *
 *  Created on: May 30, 2015
 *      Author: mocklera
 */

#include <cstdlib>
#include <fstream>
#include "Pathfinder.h"

// TODO: Help session
// in.eof()? is useful to check of end of file
// Use int maze[5][5][5] ; solve it with a 3D array
	// maze[x][y][z] = 1;
// Make separate recursive function to call from solveMaze()
	// rec(int x, int y, int z)
		// you don't have to pass the maze or the vector of results every time; just make them class members
		// it will be beneficial to return a bool. So then you can say if a path is valid by returning true or false
	// make sure you check base cases first
		// out of bounds (above 4, under 0)
		// at the end? (4, 4, 4)
		// at wall? at somewhere visited?
	// Visit the cell
		// just set the visited cell to 2
	// Recurse
		// Call the function again like rec(x + 1, y, z); rec(x - 1, y, z); rec(x, y - 1, z)....
			// Do them all separately and move only 1 cell at a time
			// you can wrap it all in an if statement since they return true or false [ if ( rec() || rec() || rec() || rec()...) ]
				// if that returns true, then store x, y, and z
				// "Before you return true, add it to the vector"

Pathfinder::Pathfinder() {
	// Default maze is all 1s
	for ( int x = 0; x < GRID_SIZE; x++ )
	{
		for ( int y = 0; y < GRID_SIZE; y++ )
		{
			for ( int z = 0; z < GRID_SIZE; z++ )
			{
				maze[x][y][z] = 1;
			}
		}
	}
}

string Pathfinder::getMaze() {
	stringstream string_maze;

	for ( int x = 0; x < GRID_SIZE; x++)
	{
		for ( int y = 0; y < GRID_SIZE; y++)
		{
			for ( int z = 0; z < GRID_SIZE; z++)
			{
				string_maze << maze[x][y][z] << " ";
			}
		}
	}

	return string_maze.str();
}

void Pathfinder::createRandomMaze() {
	for ( int x = 0; x < 5; x++ )
	{
		for ( int y = 0; y < 5; y++ )
		{
			for ( int z = 0; z < 5; z++ )
			{
				if ( x == 0 && y == 0 && z == 0 ) {
					maze[x][y][z] = 1;
				} else if ( x == 4 && y == 4 && z == 4 ) {
					maze[x][y][z] = 1;
				} else {
					int num = rand() % 2;
					maze[x][y][z] = num;
				}
			}
		}
	}
}

bool Pathfinder::importMaze(string file_name) {
	bool imported;

	// Open file
	ifstream import;
	import.open(file_name.c_str());

	// Check for bad filename
	if (import.fail()) {
		import.clear();
		imported = false;
	}
	else {
		int maze_length = 0;
		int num;
		bool error;
		for ( int x = 0; x < 5; x++) {
			for ( int y = 0; y < 5; y++ )
			{
				for ( int z = 0; z < 5; z++)
				{
					if(!import.eof() && maze_length < 125) {
						num >> import;
						maze[x][y][z] = num;
						maze_length++;
					}
					else {
						error = true;
					}
				}
			}
		}


		stringstream new_maze;
		int num;

		// Make sure the first number is a 1
		import >> num;
		if ( num != 1 ) {
			imported = false;
		}
		else {
			// Add it to the new maze if it was a 1 and start reading the rest of the file
			maze[0][0][0] = num;
			maze_length++;

			int x = 0, y = 0, z = 0;
			bool error = false; // Error flag for invalid data in a cell
			while(!import.eof() && !error)
			{
				// Grab the next number
				import >> num;
				// If it is invalid, kill the loop and the import
				if (import.fail() || num < 0 || num > 1) {
					import.clear();
					error = true;
					imported = false;
				}
				// Else, add the number to the maze and increment the length
				else {
					new_maze << num << " ";
					maze_length++;
				}
			}

			// If the last number isn't a 1 or the maze is not the correct length, kill the import
			if ( num != 1 || maze_length != 125) {
				imported = false;
			}
			// Else, replace the maze with the imported maze
			else {
				maze.str( string() );
				maze.clear();
				maze << new_maze.str();
				imported = true;
			}
		}
	}

	return imported;
}

vector<string> Pathfinder::solveMaze() {
	vector<string> a;

	char n = maze.seekg(10);

	// clear the vector
	// You might need to reverse the vector after everything
	// make sure you return maze to normal (no 2's)

	return a;
}
