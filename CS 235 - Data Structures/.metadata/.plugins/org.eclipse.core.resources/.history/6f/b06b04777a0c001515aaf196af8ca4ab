#include "BST.h"

/*
	TODO: Help session notes
	
	Review stuff
		Every node has 2 child nodes (left and right)
			Are either a node or null
			Also contain a data member
		ends are leaves, top is root

	Node Class
		Needs right, left and data
			Make data members public ;(

	Binary Search Tree
		An object made up of node objects. 
			Make a member Node* root
				Initialize it to NULL
		ADDING

		REMOVING
			If no children, just get rid of it
			If 1 child, replace the removed node with the child, and then delete the remove node
			If 2 children, Find the inorder predecessor (1 to the left, all the way right)

		CLEAR
			Make a while loop
			While the root isn't null, remove the null.

		You'll need...
			ADD function
			REMOVE function
			CLEAR function
			...and at least 3-4 more of your own (2 mandatory - for the add and remove functions)
				bool addRecursive(value, (starting point) root) -> addRecursive(int value, Node*& curr)
					BASE CASE:
						if curr == NULL
							curr = new Node(value)
							return true
					WHICH WAY TO CALL
						if value < data
							return go left
						else value > data
							return go right 

				removeRecursive(int value, Node*& curr) ------starting at the root
					BASE CASE:	
						No children -- curr->right == null && curr->left == null
							delete curr;
							curr = NULL;
							return true
						One child -- 2 parts: check for both kinds of 1 child
							N* temp = curr;
							curr = curr->right;
							delete temp;
							temp = NULL;
						Two Children -- Call inorder_predecessor(Node*& current, Node*& current->left) 
					RECURSION IS THE SAME AS IN ADD

				find()
				inorder_predecessor(Node*& N1, Node*& N2)
					BASE CASE if n2->right == NULL
						Switch data (n1->data = n2->data)
						Node* temp = n2;
						n2 = n2->left;			!! You'll always do this because it'll
						delete temp;			!! be NULL if no child to left

					recurse on inorder_predecessor(n1, n2->right)

	
*/

BST::BST() {
	root = NULL;
}

BST::~BST() {
	clear();
}

Node* BST::getRootNode() {
	return root;
}

bool BST::add(int data) {
	cout << "ADDING" << endl << endl;
	bool added;

	if ( root == NULL ) {
		cout << "BST is empty. Adding value " << data << " at the root." << endl;
		Node* temp = new Node(data);
		root = temp;
		temp = NULL;
		added = true;
		cout << "Added." << endl;
	}
	else if ( !find(data, root) ) {
		cout << "Didn't find " << data << ". Adding it to tree" << endl;
		add_recursive(data, root);
		added = true;
	}
	else {
		cout << "Not adding duplicate value " << data << "." << endl;
		// Don't add a duplicate
		added = false;
	}

	return added;
}

bool BST::remove(int data) {
	return false;
}

void BST::clear() {

}

bool BST::add_recursive(int data, Node*& current) {
	if (current == NULL) {
		current = new Node(data);
		return true;
	}
	else {
		if (data > current->data) {
			return add_recursive(data, current->right_child);
		}
		else {
			return add_recursive(data, current->left_child);
		}
	}
}

bool BST::find(int value, Node* n) {
	bool found;

	if (n == NULL) {
		found = false;
	}
	else if ( n->data == value ) {
		found = true;
	}
	else {
		if (value > n->data) {
			found = find(value, n->right_child);
		}
		else {
			found = find(value, n->left_child);
		}
	}

	return found;
}









