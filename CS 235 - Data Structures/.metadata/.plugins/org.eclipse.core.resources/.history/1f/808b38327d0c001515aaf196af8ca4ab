#pragma once

#include "BSTInterface.h"
#include "Node.h"

class BST : public BSTInterface
{
public:
	BST();
	virtual ~BST();
	virtual Node* getRootNode();
	virtual bool add(int data);
	virtual bool remove(int data);
	virtual void clear();
private:
	Node* root;
	bool add_recursive(int data, Node*& current);
	bool remove_recursive(int data, Node*& current);
	bool inorder_predecessor(Node*& n1, Node*& n2);
	bool clear_recursive(Node*& root);
	bool find(int value, Node* n);
};


/*
	TODO: Help session notes

	Review stuff
		Every node has 2 child nodes (left and right)
			Are either a node or null
			Also contain a data member
		ends are leaves, top is root

	Node Class
		Needs right, left and data
			Make data members public ;(

	Binary Search Tree
		An object made up of node objects.
			Make a member Node* root
				Initialize it to NULL
		ADDING

		REMOVING
			If no children, just get rid of it
			If 1 child, replace the removed node with the child, and then delete the remove node
			If 2 children, Find the inorder predecessor (1 to the left, all the way right)

		CLEAR
			Make a while loop
			While the root isn't null, remove the null.

		You'll need...
			ADD function
			REMOVE function
			CLEAR function
			...and at least 3-4 more of your own (2 mandatory - for the add and remove functions)
				bool addRecursive(value, (starting point) root) -> addRecursive(int value, Node*& curr)
					BASE CASE:
						if curr == NULL
							curr = new Node(value)
							return true
					WHICH WAY TO CALL
						if value < data
							return go left
						else value > data
							return go right

				removeRecursive(int value, Node*& curr) ------starting at the root
					BASE CASE:
						No children -- curr->right == null && curr->left == null
							delete curr;
							curr = NULL;
							return true
						One child -- 2 parts: check for both kinds of 1 child
							N* temp = curr;
							curr = curr->right;
							delete temp;
							temp = NULL;
						Two Children -- Call inorder_predecessor(Node*& current, Node*& current->left)
					RECURSION IS THE SAME AS IN ADD

				find()
				inorder_predecessor(Node*& N1, Node*& N2)
					BASE CASE if n2->right == NULL
						Switch data (n1->data = n2->data)
						Node* temp = n2;
						n2 = n2->left;			!! You'll always do this because it'll
						delete temp;			!! be NULL if no child to left

					recurse on inorder_predecessor(n1, n2->right)


*/
