/*
 * Pathfinder.cpp
 *
 *  Created on: May 30, 2015
 *      Author: mocklera
 */

#include <cstdlib>
#include <fstream>
#include "Pathfinder.h"

Pathfinder::Pathfinder() {
	// Default maze is all 1s
	for ( int x = 0; x < GRID_SIZE; x++ )
	{
		for ( int y = 0; y < GRID_SIZE; y++ )
		{
			for ( int z = 0; z < GRID_SIZE; z++ )
			{
				maze[x][y][z] = 1;
			}
		}
	}
}

string Pathfinder::getMaze() {
	stringstream string_maze;

	for ( int x = 0; x < GRID_SIZE; x++)
	{
		for ( int y = 0; y < GRID_SIZE; y++)
		{
			for ( int z = 0; z < GRID_SIZE; z++)
			{
				string_maze << maze[x][y][z] << " ";
			}
		}
	}

	return string_maze.str();
}

void Pathfinder::createRandomMaze() {
	for ( int x = 0; x < GRID_SIZE; x++ )
	{
		for ( int y = 0; y < GRID_SIZE; y++ )
		{
			for ( int z = 0; z < GRID_SIZE; z++ )
			{
				if ( x == 0 && y == 0 && z == 0 ) {
					maze[x][y][z] = 1;
				} else if ( x == (GRID_SIZE - 1) && y == (GRID_SIZE - 1) && z == (GRID_SIZE - 1) ) {
					maze[x][y][z] = 1;
				} else {
					int num = rand() % 2;
					maze[x][y][z] = num;
				}
			}
		}
	}
}

bool Pathfinder::importMaze(string file_name) {
	bool imported = false;
	int new_maze[GRID_SIZE][GRID_SIZE][GRID_SIZE]; // Import will be stored in this temporary maze until we are sure there are no errors

	// Open file
	ifstream import;
	import.open(file_name.c_str());

	// Check for bad filename
	if (import.fail()) {
		import.clear();
		imported = false;
	}
	else {
		// Start copying in the new maze
		int maze_length = 0;
		int num;
		bool error = false;
		for ( int x = 0; x < GRID_SIZE; x++) {
			for ( int y = 0; y < GRID_SIZE; y++ )
			{
				for ( int z = 0; z < GRID_SIZE; z++)
				{
					if(!import.eof() && maze_length < GRID_SIZE * GRID_SIZE * GRID_SIZE) {
						import >> num;
						new_maze[x][y][z] = num;
						maze_length++;
					}
					else {
						error = true;
					}
				}
			}
		}

		if ( new_maze[0][0][0] != 1 || new_maze[GRID_SIZE - 1][GRID_SIZE - 1][GRID_SIZE - 1] != 1 || !import.eof() ) {
			error = true;
		}

		if (error)
			imported = false;
		else {
			// If there are no errors, then copy the imported maze into the permanent maze.
			for ( int x = 0; x < GRID_SIZE; x++ )
			{
				for ( int y = 0; y < GRID_SIZE; y++ )
				{
					for ( int z = 0; z < GRID_SIZE; z++ )
					{
						maze[x][y][z] = new_maze[x][y][z];
					}
				}
			}
			imported = true;
		}
	}

	return imported;
}

vector<string> Pathfinder::solveMaze() {
	vector<string> a;

	// clear the vector
	// You might need to reverse the vector after everything
	// make sure you return maze to normal (no 2's)

	return a;
}
