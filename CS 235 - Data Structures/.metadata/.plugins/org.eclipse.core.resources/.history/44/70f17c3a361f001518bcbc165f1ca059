/*
 * Scanner.cpp
 *
 *  Created on: Jun 29, 2015
 *      Author: mocklera
 */

#include <cctype>
#include <iostream>
#include <sstream>
#include "Token.h"
#include "Scanner.h"

//Identifier token recognition comes last
//Skip over comments
//Use an ifstream to read in the file (has to be ifsteam since input files are write protected)
//Then you can do ifstream in; int c = in.get();
//When you hit the EOF, c will be -1 (hence using int c instead of char a)

Scanner::Scanner(char* input_file) {
	error = -1;
	line = 1;
	file.open(input_file);
}

Scanner::~Scanner() {
	clearTokens();
}

std::vector<Token*> Scanner::getTokens() {
	return tokens;
}

void Scanner::scan() {
	char token = file.get();
	while (token != EOF) {
		switch (token) {
		case ',':
			scan_punctuation(token, Token::COMMA);
			break;
		case '.':
			scan_punctuation(token, Token::PERIOD);
			break;
		case '?':
			scan_punctuation(token, Token::Q_MARK);
			break;
		case '(':
			scan_punctuation(token, Token::LEFT_PAREN);
			break;
		case ')':
			scan_punctuation(token, Token::RIGHT_PAREN);
			break;
		case ':':
			scan_colon();
			break;
		case '#':
			scan_comment();
			break;
		case '\'':
			scan_string();
			break;
		case '\n':
			line++;
			break;
		default:
			scan_id(token);
			break;
		}
		token = file.get();
	}
	add_token(token, Token::E);
	// Reads the input and looks for the next token
	//        // skip whitespace, comments (as a function maybe)
	//        // Decide what kind of token it is (look at the character! You _almost_ always know from one character in this case)
	//            // May as well use a switch for this
	//            QUOTE:
	//                scan_quote();
	//            default:
	//                scan_identifier();
	//                // On this one, read in until you reach something that isn't a letter or number.
	//                // Use stdlib functions to check for whitespace, letter, number, etc.

}

void Scanner::scan_punctuation(char token, Token::TType type) {
	add_token(token, type);
}

void Scanner::scan_colon() {
	if ( file.peek() == '-' ) {
		// Throw out the -
		file.get();
		// Create a :- token
		add_token(":-", Token::COLON_DASH);
	}
	else {
		// Create a : token
		add_token(":", Token::COLON);
	}
}

void Scanner::scan_comment() {
	// As long as the next character isn't a new line, throw it out.
	while (file.peek() != '\n') {
		file.get();
	}
}

void Scanner::scan_string() {
	std::stringstream input_str;
	char token = file.get();
	while (token != '\'') {
		input_str << token;
		token = file.get();
	}
	add_token(input_str.str(), Token::STRING);
}

void Scanner::scan_id(char token) {
	std::stringstream id;

	// If the first char of the ID is a digit, error out.
	if ( std::isdigit(token) ) {
		error = line;
	}
	// If the character is whitespace, ignore it
	else if ( std::isalnum(static_cast<unsigned char>(token)) ) {
		// Add the current token to the ID
		id << token;
		// Get the rest of the identifier
		while ( std::isalnum(static_cast<unsigned char>(file.peek())) ) {
			id << file.get();
		}
		std::string id_str = id.str();
		if(!is_keyword(id_str)) {
			add_token(id_str, Token::ID);
		}
	}
	else {
		error = line;
	}
}

bool Scanner::is_keyword(std::string id) {
	bool is_keyword;

	if ( id == "SCHEMES" ) {
		add_token(id, Token::SCHEMES);
		is_keyword = true;
	}
	else if ( id == "FACTS" ) {
		add_token(id, Token::FACTS);
		is_keyword = true;
	}
	else if ( id == "RULES" ) {
		add_token(id, Token::RULES);
		is_keyword = true;
	}
	else if ( id == "QUERIES" ) {
		add_token(id, Token::QUERIES);
		is_keyword = true;
	}
	else {
		is_keyword = false;
	}

	return is_keyword;
}

void Scanner::add_token(char t, Token::TType type) {
	std::stringstream to_s;
	to_s << t;
	Token* tok = new Token(to_s.str(), line, type);
	tokens.push_back(tok);
}

void Scanner::add_token(std::string t, Token::TType type) {
	Token* tok = new Token(t, line, type);
	tokens.push_back(tok);
}

void Scanner::clearTokens() {
	tokens.clear();
}
